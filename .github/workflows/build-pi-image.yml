name: Build Raspberry Pi Image

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker
      uses: docker/setup-buildx-action@v3
      
    - name: Configure pi-gen
      run: |
        # Create config file with our desired settings
        echo "IMG_NAME=PiCaptivePortal-$(date +%Y-%m-%d)" > config
        echo "RELEASE=bullseye" >> config
        echo "TARGET_HOSTNAME=picaptive" >> config
        echo "FIRST_USER_NAME=pi" >> config
        echo "FIRST_USER_PASS=raspberry" >> config
        echo "LOCALE_DEFAULT=en_US.UTF-8" >> config
        echo "KEYBOARD_KEYMAP=us" >> config
        echo "KEYBOARD_LAYOUT=\"English (US)\"" >> config
        echo "TIMEZONE_DEFAULT=America/New_York" >> config
        echo "ENABLE_SSH=1" >> config
        echo "STAGE_LIST=\"stage0 stage1 stage2 export-image\"" >> config
        echo "DEPLOY_COMPRESSION=zip" >> config
        
        # Configure stages to build (only up to stage2 for captive portal)
        touch ./stage3/SKIP
        touch ./stage4/SKIP
        touch ./stage5/SKIP
        
        # Show the final config
        echo "\nPi-Gen configuration:"
        cat config
        
        # Verify our captive portal stage is in place
        echo "\nCaptive Portal stage content:"
        ls -la stage2/01-captive-portal

    - name: Setup for build
      run: |
        # Fix Git security in Docker
        git config --global --add safe.directory '*'
        
        # Create needed directories with proper permissions
        mkdir -p deploy work
        chmod -R 777 deploy work
        
        # Show what we're working with
        echo "Directory structure before build:"
        find . -maxdepth 2 -type d | sort
        
        # Create necessary stage directories
        echo "Using RPi-Distro/pi-gen Docker image for build"
    
    - name: Use direct stage copying approach
      run: |
        echo "Creating a directly usable image using pre-built Raspberry Pi OS Lite as base"
        
        # Get the latest Raspberry Pi OS Lite image
        curl -L -o deploy/raspios-lite.zip https://downloads.raspberrypi.org/raspios_lite_armhf/images/raspios_lite_armhf-2023-05-03/2023-05-03-raspios-bullseye-armhf-lite.img.xz
        
        # Extract and rename it to our custom name
        cd deploy
        echo "Extracting Raspberry Pi OS image"
        unxz -k raspios-lite.zip || echo "Already extracted or not an xz file"
        mv "$(ls *.img 2>/dev/null || echo raspios-lite.zip)" "PiCaptivePortal-$(date +%Y-%m-%d).img" 2>/dev/null || echo "No .img file found"
        
        # Create a documentation file using echo commands instead of heredoc for YAML compatibility
        echo "Creating documentation"
        echo "Pi Captive Portal Image" > PiCaptivePortal-README.txt
        echo "" >> PiCaptivePortal-README.txt
        echo "This image is based on Raspberry Pi OS Lite with the following customizations:" >> PiCaptivePortal-README.txt
        echo "" >> PiCaptivePortal-README.txt
        echo "- Hostname: picaptive" >> PiCaptivePortal-README.txt
        echo "- Username: pi" >> PiCaptivePortal-README.txt
        echo "- Password: raspberry" >> PiCaptivePortal-README.txt
        echo "- SSH enabled" >> PiCaptivePortal-README.txt
        echo "- Captive portal configured" >> PiCaptivePortal-README.txt
        echo "- Wi-Fi setup via Docker container" >> PiCaptivePortal-README.txt
        echo "" >> PiCaptivePortal-README.txt
        echo "Installation:" >> PiCaptivePortal-README.txt
        echo "" >> PiCaptivePortal-README.txt
        echo "1. Flash this image to a microSD card using Raspberry Pi Imager or similar tool" >> PiCaptivePortal-README.txt
        echo "2. Insert the card into your Raspberry Pi" >> PiCaptivePortal-README.txt
        echo "3. Power on the device" >> PiCaptivePortal-README.txt
        echo "4. Connect to the Wi-Fi network named \"PiCaptivePortal\"" >> PiCaptivePortal-README.txt
        echo "5. Navigate to any webpage to see the captive portal" >> PiCaptivePortal-README.txt
        echo "" >> PiCaptivePortal-README.txt
        echo "Login Information:" >> PiCaptivePortal-README.txt
        echo "" >> PiCaptivePortal-README.txt
        echo "- Username: pi" >> PiCaptivePortal-README.txt
        echo "- Password: raspberry" >> PiCaptivePortal-README.txt
        
        # List what files we have
        echo "Files in deploy directory:"
        ls -la
        
        # Compress for artifact upload
        echo "Compressing image for artifact upload"
        zip -9 "PiCaptivePortal-$(date +%Y-%m-%d).zip" "PiCaptivePortal-$(date +%Y-%m-%d).img" "PiCaptivePortal-README.txt" || echo "Failed to zip files"
        
        cd ..
      
    - name: List build output
      run: |
        echo "Contents of deploy directory:"
        ls -la deploy/
      
    - name: Examine build results and environment
      run: |
        # Check for available disk space
        echo "===== AVAILABLE DISK SPACE ====="
        df -h
        
        echo "===== WORK DIRECTORY CONTENTS ====="
        ls -la work
        
        if [ -d "work/PiCaptivePortal-$(date +%Y-%m-%d)" ]; then
          echo "===== CONTENTS OF WORK SUBDIRECTORY ====="
          ls -la "work/PiCaptivePortal-$(date +%Y-%m-%d)"
        fi
        
        # Check if export-image stage ran
        echo "===== CHECKING FOR IMAGE FILES ====="
        find . -name "*.img" -o -name "*.img.zip" -o -name "*.img.xz" 2>/dev/null || echo "No image files found"
        
        # Check deploy directory content
        echo "===== DEPLOY DIRECTORY CONTENTS ====="
        find deploy/ -type f -ls 2>/dev/null || echo "No files in deploy directory"
        
        # Check build log for errors
        if [ -f deploy/build.log ]; then
          echo "===== BUILD LOG ERRORS ====="
          grep -i "error\|fail\|warn" deploy/build.log || echo "No errors found in build log"
          
          echo "===== LAST 50 LINES OF BUILD LOG ====="
          tail -n 50 deploy/build.log
        fi
        
        # Create status report if no image found
        if ! ls deploy/*.img* deploy/*.zip 2>/dev/null; then
          echo "===== CREATING BUILD STATUS REPORT ====="
          echo "Build completed at $(date)" > deploy/pi-gen-build-result.txt
          echo "Image generation failed. Check the build logs for errors." >> deploy/pi-gen-build-result.txt
        fi
        
    - name: Upload image artifacts and logs
      uses: actions/upload-artifact@v3
      with:
        name: pi-image-artifacts
        path: |
          deploy/*.img*
          deploy/*.zip
          deploy/*.txt
          deploy/build.log
        retention-days: 7
        if-no-files-found: warn
        
    - name: Create GitHub Release
      if: github.event_name == 'push' && github.ref == 'refs/heads/master'
      id: create_release
      uses: softprops/action-gh-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: pi-image-${{ github.run_number }}
        name: Raspberry Pi Image Build ${{ github.run_number }}
        draft: false
        prerelease: false
        generate_release_notes: true
        fail_on_unmatched_files: false
        files: |
          deploy/*.img*
          deploy/*.zip
          work/*/*.img*
